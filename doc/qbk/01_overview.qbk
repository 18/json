[/
    Copyright (c) 2019 Vinnie Falco (vinnie.falco@gmail.com)
    Copyright (c) 2020 Krystian Stasiowski (sdkrystian@gmail.com)

    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

    Official repository: https://github.com/cppalliance/json
]

[section Overview]
[block'''<?dbhtml stop-chunking?>''']

[/-----------------------------------------------------------------------------]

[section Introduction]

This library provides containers and algorithms which implement JSON
([@https://json.org/ "JavaScript Object Notation"]), a lightweight
data-interchange format. This format is easy for humans to read and
write, and easy for machines to parse and generate. It is based on a
subset of the JavaScript Programming Language,
[@https://www.ecma-international.org/ecma-262/10.0/index.html Standard ECMA-262].
JSON is a text format that is language-independent but uses conventions
that are familiar to programmers of the C-family of languages, including
C, C++, C#, Java, JavaScript, Perl, Python, and many others. These
properties make JSON an ideal data-interchange language.

[endsect]

[/-----------------------------------------------------------------------------]

[section Motivation]

Boost.JSON is designed with the following goals in mind:

* Require only C++11.
* Provide a safe, easy-to-use, and versatile interface
that is uniform across all C++ versions.
* Offer best-in-class performance for parsing and serialization
without compromising on features or interface. 
* Amortized constant key lookup.
* Support for stateful allocators.
* An incremental parser and serializer.
* Optional support for non-standard JSON syntaxes.
* Security-aware treatment of untrusted inputs.
* Fast compile times.

There are an overwhelming number of JSON libraries. A common theme 
throughout is an emphasis on parsing performance or feature richness.
This library takes a different approach: it provides a carefully
designed JSON container, __value__, engineered from the ground up to be
ideally suited as a vocabulary type, and appropriate for use in
public interfaces. However, by using this library you do not sacrifice performance for
an easy-to-use interface. Boost.JSON beating RapidJSON in 8/10 parsing benchmarks,
and considerably outperforms nlohmann on all ten.

[endsect]

[/-----------------------------------------------------------------------------]

[section Requirements]

With Boost:

* [*C++11]: Robust support for most language features.

Without Boost:

* [*C++17]: Support for __string_view__ and __memory_resource__,

* definition of the macro `BOOST_JSON_STANDALONE`, and

* if `BOOST_JSON_HEADER_ONLY` is not defined, addition of the file
`src/src.cpp` to the target application.

[endsect]

[/-----------------------------------------------------------------------------]

[section Configuration]

Boost.JSON has been tested with the following compilers:
msvc-14.1+, gcc 4.8.4+, and clang 3.6+.

Typically a program will need to link statically or dynamically with the
Boost.JSON library, which is either delivered with Boost or built separately.
Please visit the [@boost:/more/getting_started.html Boost documentation]
for instructions on how to build and link with Boost libraries for your
particular environment.

Alternatively, Boost.JSON may be used in a header-only configuration by
defining the macro `BOOST_JSON_HEADER_ONLY` and simply including the
desired header files. 

[endsect]

[/-----------------------------------------------------------------------------]

[heading Frequently Asked Questions]

[variablelist

[[
    "Isn't simdjson faster?"
][
    While simdjson is indeed faster, these libraries simply are not comparable.
    The output of the simdjson parser is a read-only structure. 
    In other words, it can't be changed, and the only way to create one is
    by parsing a JSON string. On the other hand, Boost.JSON allows you to
    modify the output, or even build a JSON document from scratch. 
]]

[[
    "I want to parse directly into my own data structures"
][
    The purpose of this library is to enable algorithms which implement
    JSON functionality in their public interfaces to be interoperable,
    by providing a __value__ type that meets the bar for vocabulary
    type suitability. Parsing directly into a user defined type offers
    some advantages but is not the goal of the library. However, users
    who wish to parse directly into their own types may implement a
    custom handler for this purpose.
]]

[[
    "Why not use a standard __Allocator__?"
][
    Using standard allocators would require that __value__ be declared
    as a class template, which would impose an additional compilation
    burden. By avoiding the template, most of the function definitions
    in the library can be excluded from the headers and emitted in a
    separate static or dynamic library.
]]

[[
    "Why use __storage_ptr__ over __polymorphic_allocator__?
][
    __polymorphic_allocator__ treats the memory resource as a reference
    with respect to ownership. Boost.JSON uses a reference counted
    smart pointer container to simplify the lifetime management of
    memory resources. In addition to being reference counted,
    __storage_ptr__ can function as an uncounted reference wrapper
    around a __memory_resource__.
]]

[[
    "Why __string__ instead of __std_string__?"
][
    The string provided by the library uses the __storage_ptr__ allocator
    model, has the same interface on all C++ versions, and has an
    optimized class layout to keep the size of JSON values small.
    __string__ also implements an improved interface that replaces
    extraneous overloads with ones that use __string_view__.
]]

]

[/-----------------------------------------------------------------------------]

[section Credits]

This library wouldn't be where it is today without the help of
[@https://github.com/pdimov Peter Dimov]
for design advice and optimization assistance.

[endsect]

[/-----------------------------------------------------------------------------]

[endsect]
