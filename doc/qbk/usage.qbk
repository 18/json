[/
    Copyright (c) 2019 Vinnie Falco (vinnie dot falco at gmail dot com)

    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

    Official repository: https://github.com/vinniefalco/json
]

[section Usage]
[block'''<?dbhtml stop-chunking?>''']

[note
    Sample code and identifiers used throughout are written as if
    the following declarations are in effect:
```
#include <boost/json.hpp>
using namespace json;
```
]

JSON documents are stored in memory as instances of the
__SemiRegular__ type __value__, satisfying __DefaultConstructible__
and __Copyable__. These instances  are implemented as a
[@https://en.wikipedia.org/wiki/Tagged_union ['tagged union]],
and can dynamically store any of the six defined JSON value types:

* [*object]: A collection of name/value pairs, also known as an
  [@https://en.wikipedia.org/wiki/Associative_array ['associative array]].

* [*array]: An ordered list of values, like a __vector__.

* [*string]: A sequence of zero or more Unicode characters,
  similar to a __std_string__

* [*number]: An integral or floating point value.

* [*boolean]: A `bool`. Either `true` or `false`.

* [*null]: A ['monostate] value, equivalent to `nullptr`.

[h4 Working With Values]

A default constructed __value__ produces a null JSON element. Alternatively,
the value may be constructed with a __kind__ constant to produce an empty
instance of that kind. Here, `jv1` and `jv2` are both null:

```
value jv1;
value jv2( kind::null );
```

The member function
[link json.ref.boost__json__value.kind `value::kind`]
may be used to query the kind stored in the value. Alternatively, member
functions like
[link json.ref.boost__json__value.is_object `value::is_object`] or
[link json.ref.boost__json__value.is_number `value::is_number`]
may be used to check whether or not the value is a particular kind:

```
value jv( kind::object );
assert( jv.kind() == kind::object );
assert( jv.is_object() );
assert( ! jv.is_number() );
```

After a __value__ is constructed, its kind can change dynamically by
assignment from another value, from calling the member function
[link json.ref.boost__json__value.reset `value::reset`], or by calling
functions like
[link json.ref.boost__json__value.emplace_array `value::emplace_array`] or
[link json.ref.boost__json__value.emplace_bool `value::emplace_bool`]. In
all cases, the previous contents of the value are destroyed:

```
value jv;
jv = value( kind::array )
assert( jv.is_array() );
jv.emplace_string();
assert( jv.is_string() );
```

The emplace members of `value` return a suitably typed reference to the
underlying container representing the kind. For example, the call to
[link json.ref.boost__json__value.emplace_string `value::emplace_string`]
above returns a
[link json.ref.boost__json__string `string&`].
The library provides a suitable type for each possible value of __kind__
(except for nulls). This table shows the types corresponding to each kind:

[table
[ [Kind] [Type] [Description] ]
[
    [[link json.ref.boost__json__kind `kind::object`]]
    [[link json.ref.boost__json__object `object`]]
    [
        An associative array of string keys mapping to
        __value__ elements with an interface similar to
        __std__unordered_map__, that remembers insertion
        order.
    ]
]
[
    [[link json.ref.boost__json__kind `kind::array`]]
    [[link json.ref.boost__json__array `array`]]
    [
        An ordered list of __value__ elements with an
        interface similar to __vector__.
    ]
]
[
    [[link json.ref.boost__json__string `kind::string`]]
    [[link json.ref.boost__json__kind `string`]]
    [
        A
        [@https://en.wikipedia.org/wiki/UTF-8 ['UTF-8]]
        encoded
        [@https://en.wikipedia.org/wiki/Unicode Unicode]
        [@https://en.wikipedia.org/wiki/String_(computer_science) string]
        of characters with an interface similar to
        __std_string__.
    ]
]
[
    [[link json.ref.boost__json__kind `kind::number`]]
    [[link json.ref.boost__json__number `number`]]
    [
        A type representing an integral or floating point
        number implemented as a
        [@https://en.wikipedia.org/wiki/Tagged_union ['tagged union]].
    ]
]
[
    [[link json.ref.boost__json__kind `kind::boolean`]]
    [[@https://en.cppreference.com/w/cpp/keyword/bool `bool`]]
    [
        A `bool` holding `true` or `false`.
    ]
]
[
    [[link json.ref.boost__json__kind `kind::null`]]
    []
    [
        A monostate value representing null.
    ]
]
]

We can use the emplace return value to perform an assignment or
to capture a reference to the underlying representation for later
inspection or modification:

```
value jv;
jv.emplace_string() = "Hello, world!";

number& num = jv.emplace_number(); // changes to kind::number
num = 1;
```

If the __kind__ of a value is already known, functions such as
[link json.ref.boost__json__value.as_bool `value::as_bool`] or
[link json.ref.boost__json__value.as_string `value::as_string`]
may be used to obtain a reference to the underlying representation
without changing the existing value:

```
value jv( kind::bool );
jv.as_bool() = true;

jv.as_string() = "Hello, world!"; // throws system_error !!
```

However, as shown above these functions throw an exception if the kind
in the value does not match the kind implied by the function signature.
This can be used as a concise form of validation: access values as if
they were the right type, but handle the resulting exception indicating
if the schema of the JSON is not valid.

We can query a value for its underlying representation of a particular
kind in a way that does not throw exceptions by requesting a pointer
which may be null, instead of a reference. Here we use
[link json.ref.boost__json__value.if_string.overload1 `value::if_string`]
to conditionally perform an assignment without using exceptions:

```
value jv( kind::string );
if(auto ptr = jv.if_string())
    *ptr = "Hello, world!";
```

[tip
    If the value's kind is known statically, a reference to the underlying
    representation may be obtained by dereferencing the pointer without
    checking. This avoids the code overhead of the possible exception
    when using, for example
    [link json.ref.boost__json__value.as_string `value::as_string`]:
    ```
    value jv( kind::string );

    *jv.if_string() = "Hello, world!";

    // The compiler's static analysis can see that
    // a null pointer is never dereferenced above.
    ```
]

[/-----------------------------------------------------------------------------]

[The String Type]

[/-----------------------------------------------------------------------------]

[The Array Type]

[/-----------------------------------------------------------------------------]

[The Object Type]

[/-----------------------------------------------------------------------------]

[heading Parsing]

[/-----------------------------------------------------------------------------]

[heading Serialization]

[/-----------------------------------------------------------------------------]

[heading Value Exchange]

[/-----------------------------------------------------------------------------]

[endsect]
